# Transport Layer Services
- transport protocols are responsible for breaking the messages into segments that can be sent to the network layer
- Two main protocols are TCP and UDP
- Actions on the Transport layer
	- Sender
		- passed an application layer message
		- determines segment header fields values
		- segmentation
		- passes segment to IP
	- Receiver
		- receives segment from IP
		- checks header values
		- reassembles application layer message
		- demultiplexes message up to application via socket
- Network layer - logical communication between hosts
- Transport layer - logical communication between processes
	- relies on network layer services
- TCP
	- reliable, ordered delivery
	- congestion control
	- flow control
	- connection setup
- UDP
	- unreliable, unordered delivery
	- doesn't add many features on top of IP, just allows easy use of it
- Services that these protocols can't do
	- delay guarantees (can't tell you how long it will take to send and receive)
	- bandwidth guarantees (can't assure how much bandwidth will be available)
# Mux and Demux

- Multiplexing
	- Combining multiple data streams into one
- Demultiplexing
	- When servers receive a multiplexed signal, they need to demultiplex it
	- Get the right packets to the right application
	- The server uses header and socket data to do this
	- UDP
		- IP/UDP datagrams with the same destination port will go to the same socket
	- TCP
		- 4 identifiers (4-tuple)
			- source IP address
			- source port number
			- destination IP address
			- destination port number
		- receiver will direct segment based on the 4-tuple
		- servers may support multiple TCP sockets
			- each socket is identified by the 4-tuple
			- each socket associated with a different client
# UDP

- UDP segments may be
	- out of order
	- lost
- connectionless
	- no handshake
	- each IDP segment handled independently of others
- UDP use
	- VOIP
	- DNS
	- SNMP
	- HTTP/3
		- HTTP/3 reliability and congestion control comes from application layer
- Actions
	- Sender Actions
		- passed an application layer message
		- creates UDP segment header fields
		- creates UDP segments
		- passed to IP
	- Receiver Actions
		- receives from IP
		- checks UDP checksum header value
		- extracts message, reassembly
		- demuxes message to application via socket
							![](https://github.com/RealVishy/NetFundNotes/blob/main/41092%20Network%20Fundamentals%20Resources/41092%20Module%205%20Resources/UDP%20segments.png)
- UDP Checksum
	- checksum adds all the values of the of the packet
	- the receiver create a check sum from it's data, checks it with the checksum sent to determine if there were any errors
		- e.g. a flipped bit
- Internet check sum
	- Sender
		- treats the content of the segment as 16-bit integers
		- adds the numbers
		- the checksum value is put into the header
	- Receiver
		- computer checksum
		- check if computer value are equal
		- if not, there is an error
		- being equal does not necessarily mean there was no error
							![[Pasted image 20240318125441.png]](https://github.com/RealVishy/NetFundNotes/blob/main/41092%20Network%20Fundamentals%20Resources/41092%20Module%205%20Resources/wrap%20around.png)
	- you add the wrap around starting from ones, so in this case you'd just add one
	- The check sum is a binary flip of the sum, so you can add sum and checksum to easily see if the same sum was gotten
		- e.g. sum = 1001, checksum = 0110, 1001+0110=1111
# Principles of reliable data transfer
- To have reliable data transfer, you either need a reliable channel or a reliable protocol
- Reliable protocols will vary in complexity depending on characteristics of unreliable channel
- The lecture then goes over how you could develop a reliable data transfer protocol
	- rdt 1 - reliable channel
		- no protocol error checking or loss detection needed
	- rdt 2 - channel with bit errors
		- underlying channel may flip bits, how to recover from this?
		- checksums can be used to detect errors
		- to recover from these errors we can use
			- ACKs - acknowledgements to say the we received the data
			- NAKs - negative acknowledgements to say the data was not received properly
			- sender retransmits last packet on receipt of a NAK
		- there is a fatal flaw here, what if a packet isn't sent at all?
		- what if acknowledgement has an error
	- rdt 2.1
		- adding sequence number
		- we can add just 0 and 1
			- allows to check for duplicate packet and can resend packet
		- check if ACKs or NAKs are corrupted
		- receiver must check the sequence number
	- rdt 2.2 - NAK-free
		- instead of sending NAK, send previous ACK
		- duplicate ACK means to retransmit
	- rdt 3.0 -  error and loss
		- sender will wait a 'reasonable' amount of time for ACK
		- retransmit if ACK isn't received within this time
		- if delayed and not lost
			- the receiver will send ACK
			- sender will determine whether ACK is a duplicate and ignore if so
		- speed isn't great because we have to wait for responses
		- Pipelining
			- pipelining allows for multiple packets to be sent at one
			- then multiple ACKs can be sent back once packets are received
			- range of sequence numbers needs to increase
			- A buffer is needed at both sender and receiver
			- timeouts still apply to individual packets and ACKs
			- Go-Back-N
				- always send ACK for correctly received packet, only highest in-order seq
					![[Pasted image 20240318132706.png]](https://github.com/RealVishy/NetFundNotes/blob/main/41092%20Network%20Fundamentals%20Resources/41092%20Module%205%20Resources/pipelining%20ack%20protocol.png)
			- Selective repeat
				- individual ACK each packet
					- buffer packets as needed
				- sender will resend packets when doesn't receive ack
